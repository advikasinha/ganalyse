# -*- coding: utf-8 -*-
"""Hooks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gfLA9aPQh2ESk1jPMpiKqtdL1jPN7Dw6
"""

import torch
import torch.nn as nn
from torchinfo import summary

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(3, 16, kernel_size=3, stride=1, padding=1)
        self.relu = nn.ReLU()
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2)

        self.conv2 = nn.Conv2d(16, 32, kernel_size=3, stride=1, padding=1)
        self.relu2 = nn.ReLU()
        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)

        self.flatten = nn.Flatten()
        self.fc = nn.Linear(32 * 8 * 8, 10)

    def forward(self, x):
        x = self.conv1(x)
        x = self.relu(x)
        x = self.pool(x)

        x = self.conv2(x)
        x = self.relu2(x)
        x = self.pool2(x)

        x = self.flatten(x)
        x = self.fc(x)
        return x

def forward_hook(module, input, output):
  if output.abs().max() < 1e-5:
    print(f"Potential Bottleneck in layer {module}")
  print("Inside " + module.__class__.__name__ + "'s forward")
  print("Input: ", input)
  print("Output: ", output)

def backward_hook(module, grad_input, grad_output):
    print("Inside " + module.__class__.__name__ + "'s backward")
    print("grad_input: ", grad_input)
    print("grad_output: ", grad_output)

model = SimpleCNN()
print(summary(model, input_size=(1, 3, 32, 32)))

fhandles = []
bhandles = []
for layer in [model.conv1, model.conv2]:
    fhandles.append(layer.register_forward_hook(forward_hook))
    bhandles.append(layer.register_full_backward_hook(backward_hook))

dummy_input = torch.randn(1, 3, 32, 32)
target = torch.randn(1, 10)

output = model(dummy_input)

criterion = nn.MSELoss()
loss = criterion(output, target)

loss.backward()
print("Loss:", loss.item())

for handle in fhandles + bhandles:
    handle.remove()